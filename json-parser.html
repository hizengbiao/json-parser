<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="nav.css">
    <script src="nav.js" defer></script>
    <style>
        :root {
            --bg-color: #f4f6f8;
            --panel-bg: #ffffff;
            --border-color: #d1d5db;
            --text-color: #333;
            --key-color: #cf222e;
            --string-color: #0a3069;
            --number-color: #0550ae;
            --boolean-color: #cf222e;
            --null-color: #6e7781;
            --preview-color: #8c959f;
            --gutter-bg: #f6f8fa;
            --gutter-color: #bbb;
            --hover-row: #fffbdd;
            --hover-path-bg: rgba(0, 0, 0, 0.06);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: var(--bg-color);
            color: var(--text-color);
            height: 100vh;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
        }

        /* Toolbar Styles */
        .main-actions {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 8px 16px;
            font-size: 14px;
            font-weight: 600;
            border: 1px solid rgba(27, 31, 35, 0.15);
            border-radius: 6px;
            cursor: pointer;
            transition: 0.2s;
            background-color: #fff;
        }

        .btn-primary {
            background-color: #0969da;
            color: white;
            border: none;
        }

        .btn-primary:hover {
            background-color: #0a58ca;
        }

        .btn-default:hover {
            background-color: #f3f4f6;
        }

        /* Layout */
        .container {
            display: flex;
            flex: 1;
            flex-direction: column;
            background: var(--panel-bg);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
            height: calc(100% - 80px);
            /* Adjust based on toolbar height */
        }

        /* Tabs */
        .tabs-header {
            display: flex;
            background: #f6f8fa;
            border-bottom: 1px solid var(--border-color);
            align-items: center;
            padding: 0 10px;
            height: 48px;
        }

        .tab-btn {
            padding: 12px 20px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            color: #57606a;
            border-bottom: 2px solid transparent;
            display: flex;
            align-items: center;
            gap: 6px;
            user-select: none;
        }

        .tab-btn:hover {
            color: #24292f;
            background: rgba(0, 0, 0, 0.02);
        }

        .tab-btn.active {
            color: #0969da;
            border-bottom-color: #0969da;
            background: #fff;
            /* Tab look */
            border-radius: 6px 6px 0 0;
            border: 1px solid var(--border-color);
            border-bottom: none;
            margin-bottom: -1px;
            /* Overlap border */
            position: relative;
            z-index: 1;
        }

        .tab-spacer {
            flex: 1;
        }

        .tab-actions {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        /* Editor container */
        .editor-content {
            flex: 1;
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* Views */
        .view-panel {
            flex: 1;
            width: 100%;
            height: 100%;
            display: none;
            /* Hidden by default */
            flex-direction: column;
            overflow: auto;
        }

        .view-panel.active {
            display: flex;
        }

        /* Source Code Editor */
        textarea#json-input,
        textarea#minified-output {
            flex: 1;
            width: 100%;
            border: none;
            padding: 15px;
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
            font-size: 13px;
            resize: none;
            outline: none;
            box-sizing: border-box;
            line-height: 1.5;
        }

        /* Tree Viewer Styles */
        .json-tree {
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
            font-size: 13px;
            line-height: 1.6;
            width: 100%;
            padding: 10px 10px 10px 50px;
            /* Left padding for gutter */
            box-sizing: border-box;
            counter-reset: line;
            position: relative;
            /* Anchor for absolute line numbers */
        }

        .json-node {
            border-radius: 4px;
            transition: background-color 0.2s;
        }

        .json-node.object-node {
            margin: 3px 0;
            padding: 5px;
            border: 1px solid rgba(0, 0, 0, 0.08);
            background-color: transparent;
            /* position: relative; Removed to allow line-num to anchor to json-tree */
        }

        /* Dark mode adjustments if needed, though mostly using rgba opacity logic */

        .json-row {
            display: flex;
            flex-wrap: nowrap;
            align-items: center;
            /* Center items vertically in the header */
            padding-left: 0;
            /* position: relative; Removed for gutter logic */
        }

        /* Line Numbers (Gutter) */
        .line-num {
            position: absolute;
            left: 5px;
            width: 35px;
            text-align: right;
            color: #6e7781;
            font-size: 12px;
            user-select: none;
            cursor: default;
        }

        .line-num::before {
            counter-increment: line;
            content: counter(line);
        }

        .json-node:hover>.json-row {
            /* Only highlight the header row of the current card, not the entire card content */
            background-color: transparent;
        }

        .json-node.object-node:hover {
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
            border-color: rgba(0, 0, 0, 0.2);
            background-color: rgba(0, 0, 0, 0.04);
            /* Highlight on hover (and bubbles to parents) */
        }

        .content-box {
            flex: 1;
            display: block;
            /* Wrapping */
            white-space: normal;
            word-break: break-all;
            line-height: 1.5;
            min-width: 0;
        }

        .json-children {
            width: 100%;
            padding-left: 10px;
            /* Structural indentation */
            padding-top: 2px;
            /* Optional guide line */
            margin-left: 2px;
            /* Align with guide line */
        }

        /* Collapsing */
        .json-node.collapsed .json-children {
            display: none;
        }

        .json-node.collapsed .close-bracket-row {
            display: none;
        }

        .json-node.collapsed .preview-text {
            display: inline-block;
        }

        .json-node.collapsed .collapsible-icon::after {
            content: "+";
        }

        .collapsible-icon {
            cursor: pointer;
            user-select: none;
            display: inline-block;
            width: 14px;
            text-align: center;
            color: #57606a;
            margin-right: 2px;
            font-weight: bold;
        }

        .collapsible-icon::after {
            content: "-";
        }

        .collapsible-icon:hover {
            color: #0969da;
        }

        .preview-text {
            display: none;
            color: var(--preview-color);
            font-style: italic;
            cursor: pointer;
            user-select: none;
            margin: 0 5px;
            font-size: 12px;
            background: #f0f2f4;
            padding: 0 6px;
            border-radius: 4px;
        }

        .preview-text:hover {
            background: #e6e8eb;
            color: #333;
        }

        /* Syntax Highlighting */
        .key {
            color: var(--key-color);
            cursor: pointer;
        }

        .string {
            color: var(--string-color);
        }

        .number {
            color: var(--number-color);
        }

        .boolean {
            color: var(--boolean-color);
        }

        .null {
            color: var(--null-color);
            font-weight: bold;
        }

        .punctuation {
            color: #57606a;
        }

        /* Action Buttons */
        .action-group {
            opacity: 0;
            display: inline-flex;
            gap: 4px;
            margin-left: 10px;
            transition: opacity 0.1s;
            vertical-align: middle;
        }

        .json-row:hover .action-group {
            opacity: 1;
        }

        .tiny-btn {
            font-size: 11px;
            padding: 1px 6px;
            border: 1px solid #d1d5db;
            background: #fff;
            border-radius: 3px;
            cursor: pointer;
            color: #57606a;
        }

        .tiny-btn:hover {
            border-color: #0969da;
            color: #0969da;
        }

        .icon-btn {
            border: none;
            background: none;
            cursor: pointer;
            color: #57606a;
            font-size: 14px;
            padding: 4px 8px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .icon-btn:hover {
            background-color: #eaeef2;
            color: #0969da;
        }

        .icon-btn:disabled,
        .btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            pointer-events: none;
            filter: grayscale(100%);
        }

        /* Helpers */
        .hidden {
            display: none !important;
        }



        #toast {
            visibility: hidden;
            min-width: 250px;
            background-color: #24292f;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 12px;
            position: fixed;
            z-index: 1000;
            left: 50%;
            bottom: 30px;
            transform: translateX(-50%);
            font-size: 14px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            opacity: 0;
            transition: opacity 0.3s, bottom 0.3s;
        }

        #toast.show {
            visibility: visible;
            opacity: 1;
            bottom: 50px;
        }

        #error-msg {
            color: #cf222e;
            background: #ffebe9;
            padding: 10px;
            border: 1px solid #ff818266;
            border-radius: 6px;
            margin-bottom: 15px;
            display: none;
        }

        /* Nav Bar */
        .nav-header {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #d0d7de;
            align-items: center;
            flex-wrap: wrap;
            justify-content: center;
        }

        .nav-item {
            text-decoration: none;
            color: #57606a;
            font-size: 14px;
            font-weight: 600;
            padding: 5px 10px;
            border-radius: 6px;
            transition: 0.2s;
        }

        .nav-item:hover {
            background-color: #f3f4f6;
            color: #24292f;
        }

        .nav-item.active {
            background-color: #0969da;
            color: white;
        }

        .edit-input {
            font-family: inherit;
            font-size: inherit;
            border: 1px solid #0969da;
            border-radius: 3px;
            padding: 0 4px;
            margin: 0;
            color: inherit;
            background: #fff;
            min-width: 60px;
            outline: none;
            box-shadow: 0 0 0 2px rgba(9, 105, 218, 0.2);
        }

        .subtree-editor-container {
            padding: 10px;
            background: #fff;
            border: 1px solid #0969da;
            border-radius: 6px;
            margin: 5px 0;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .subtree-textarea {
            width: 100%;
            min-height: 200px;
            font-family: 'SFMono-Regular', Consolas, monospace;
            font-size: 13px;
            padding: 10px;
            border: 1px solid #d0d7de;
            border-radius: 4px;
            resize: vertical;
            outline: none;
            box-sizing: border-box;
            margin-bottom: 10px;
        }

        .subtree-textarea:focus {
            border-color: #0969da;
            box-shadow: 0 0 0 2px rgba(9, 105, 218, 0.2);
        }
    </style>
</head>

<body>

    <div class="main-actions">
        <!-- Global Actions -->
        <button class="btn btn-default" onclick="handleFormat()" title="Ê†ºÂºèÂåñ‰∏∫Ê†ëÁä∂ËßÜÂõæ">‚ö° Ê†ºÂºèÂåñ</button>
        <button class="btn btn-default" onclick="showEditor()" title="ÁºñËæëÊ∫êÁ†Å">‚úèÔ∏è ÁºñËæë</button>
        <button class="btn btn-default" onclick="handleMinify()" title="ÂéãÁº© JSON">üì¶ ÂéãÁº©</button>
        <button class="btn btn-default" onclick="fixJson()" title="‰øÆÂ§çÈùûÊ†áÂáÜ JSON">üîß ‰øÆÂ§ç</button>
        <button class="btn btn-default" onclick="clearAll()" title="Ê∏ÖÁ©∫ÂÜÖÂÆπ">üßπ Ê∏ÖÁ©∫</button>
        <div style="width: 15px;"></div>
        <button class="btn btn-default" onclick="undo()" title="Êí§ÈîÄ (Ctrl+Z)">‚Ü©Ô∏è Êí§ÈîÄ</button>
        <button class="btn btn-default" onclick="redo()" title="ÈáçÂÅö (Ctrl+Y)">‚Ü™Ô∏è ÈáçÂÅö</button>

        <!-- Tree Actions (Dynamic visibility) -->
        <div class="action-separator" style="width:1px; height:20px; background:#e1e4e8; margin:0 10px;"></div>
        <div id="tree-toolbar" style="display:flex; gap:5px;">
            <button class="icon-btn" onclick="copyCurrentContent()" id="btn-copy" title="Â§çÂà∂ÂÜÖÂÆπ">üìã Â§çÂà∂</button>
            <button class="icon-btn tree-only" onclick="toggleAll(true)" title="ÂÖ®ÈÉ®Â±ïÂºÄ">üìñ Â±ïÂºÄ</button>
            <button class="icon-btn tree-only" onclick="toggleAll(false)" title="ÂÖ®ÈÉ®Êî∂Ëµ∑">üìï Êî∂Ëµ∑</button>
            <button class="icon-btn tree-only" onclick="sortJson(true)" title="ÊåâKeyÂçáÂ∫è">‚¨áÔ∏è ÂçáÂ∫è</button>
            <button class="icon-btn tree-only" onclick="sortJson(false)" title="ÊåâKeyÈôçÂ∫è">‚¨ÜÔ∏è ÈôçÂ∫è</button>
        </div>
    </div>

    <div id="error-msg"></div>

    <div class="container">
        <!-- content -->
        <div class="editor-content">
            <!-- View 1: Source Input -->
            <div id="view-source" class="view-panel active">
                <textarea id="json-input" placeholder="ËØ∑Âú®Ê≠§Á≤òË¥¥ JSON..."></textarea>
            </div>

            <!-- View 2: Tree Output -->
            <div id="view-tree" class="view-panel">
                <div id="json-output" class="json-tree"></div>
            </div>
        </div>
    </div>

    <div id="toast">ÊèêÁ§∫‰ø°ÊÅØ</div>

    <script>
        const inputArea = document.getElementById('json-input');
        const outputDiv = document.getElementById('json-output');
        const errorMsg = document.getElementById('error-msg');

        const viewSource = document.getElementById('view-source');
        const viewTree = document.getElementById('view-tree');
        const treeToolbar = document.getElementById('tree-toolbar');

        let currentObj = null;
        let isTreeMode = false;

        // Undo/Redo
        const historyStack = [];
        let historyIndex = -1;
        let isInputting = false;

        saveState();

        inputArea.addEventListener('input', () => {
            if (!isInputting) {
                isInputting = true;
                setTimeout(() => {
                    saveState();
                    isInputting = false;
                }, 500);
            }
        });

        document.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'z') { e.preventDefault(); undo(); }
            if ((e.ctrlKey || e.metaKey) && e.key === 'y') { e.preventDefault(); redo(); }
        });

        function saveState() {
            const val = inputArea.value;
            if (historyIndex >= 0 && historyStack[historyIndex] === val) return;
            if (historyIndex < historyStack.length - 1) historyStack.splice(historyIndex + 1);
            historyStack.push(val);
            historyIndex++;
        }

        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                inputArea.value = historyStack[historyIndex];
                // If we are in tree mode, maybe refresh tree? 
                // Or just stay in source mode.
            }
        }

        function redo() {
            if (historyIndex < historyStack.length - 1) {
                historyIndex++;
                inputArea.value = historyStack[historyIndex];
            }
        }

        // --- View Switching Logic ---
        function switchMode(mode) {
            const treeBtns = document.querySelectorAll('.tree-only');

            if (mode === 'source') {
                isTreeMode = false;
                viewSource.classList.add('active');
                viewTree.classList.remove('active');

                // Disable tree-only buttons, but keep toolbar visible for layout stability
                treeBtns.forEach(btn => btn.disabled = true);
            } else {
                // To Tree
                isTreeMode = true;
                viewSource.classList.remove('active');
                viewTree.classList.add('active');

                // Enable tree-only buttons
                treeBtns.forEach(btn => btn.disabled = false);
            }
        }

        function showEditor() {
            // Switch back to source
            // Ideally, populate with formatted JSON if we were in tree mode?
            // Optional: User might want to keep what they typed.
            // But if they sorted, we should sync back.
            if (currentObj && isTreeMode) {
                inputArea.value = JSON.stringify(currentObj, null, 4);
                saveState();
            }
            switchMode('source');
        }

        function handleFormat() {
            // Triggered by Format Button
            if (parseAndRender()) {
                switchMode('tree');
                showToast("Ê†ºÂºèÂåñÊàêÂäü ‚úÖ");
            }
        }

        function handleMinify() {
            // Prioritize currentObj if we are in Tree Mode (to capture sorting)
            if (isTreeMode && currentObj) {
                inputArea.value = JSON.stringify(currentObj);
                saveState();
                switchMode('source');
                showToast("ÂéãÁº©ÊàêÂäü (Â∑≤‰øùÁïôÊéíÂ∫è) ‚úÖ");
                return;
            }

            const raw = inputArea.value.trim();
            if (!raw) return;
            try {
                const parsed = JSON.parse(raw);
                inputArea.value = JSON.stringify(parsed);
                saveState();
                switchMode('source');
                showToast("ÂéãÁº©ÊàêÂäü ‚úÖ");
                errorMsg.style.display = 'none';
            } catch (e) {
                showError(e);
            }
        }

        function fixJson() {
            let raw = inputArea.value.trim();
            if (!raw) return;
            try {
                raw = raw.replace(/\/\/.*$/gm, "").replace(/\/\*[\s\S]*?\*\//g, "");
                const jsonpMatch = raw.match(/^\s*[a-zA-Z_$][a-zA-Z0-9_$]*\s*\(([\s\S]*)\)\s*;?\s*$/);
                if (jsonpMatch && jsonpMatch[1]) raw = jsonpMatch[1];

                let obj;
                try {
                    const fn = new Function("return " + raw);
                    obj = fn();
                } catch (firstErr) {
                    // Failover: Try wrapping in braces (for bare key:value pairs)
                    try {
                        const fn = new Function("return {" + raw + "}");
                        obj = fn();
                    } catch (secondErr) {
                        throw firstErr; // Throw validation error from first attempt (or generic)
                    }
                }

                inputArea.value = JSON.stringify(obj, null, 4);

                saveState();
                handleFormat(); // Go to tree view
                showToast("‰øÆÂ§çÂπ∂Ê†ºÂºèÂåñÊàêÂäü ‚úÖ");
            } catch (e) {
                showError({ message: "‰øÆÂ§çÂ§±Ë¥•: " + e.message });
            }
        }

        function clearAll() {
            inputArea.value = '';
            outputDiv.innerHTML = '';
            currentObj = null;
            switchMode('source');
            errorMsg.style.display = 'none';
        }

        function parseAndRender() {
            const raw = inputArea.value.trim();
            if (!raw) {
                // If empty, just switch but show nothing? Or stay?
                // showToast("ËØ∑ËæìÂÖ• JSON");
                // Allow switch but it's empty
                outputDiv.innerHTML = '';
                return true;
            }
            try {
                const parsed = JSON.parse(raw);
                currentObj = parsed;
                outputDiv.innerHTML = '';
                errorMsg.style.display = 'none';

                const tree = buildTree(parsed, 0, null, true, []);
                outputDiv.appendChild(tree);
                return true;
            } catch (e) {
                showError(e);
                switchMode('source'); // Switch back to show error context
                return false;
            }
        }

        function showError(e) {
            errorMsg.textContent = "JSON ÈîôËØØ: " + e.message;
            errorMsg.style.display = 'block';
        }

        function copyCurrentContent() {
            // Smart copy based on mode
            if (isTreeMode && currentObj) {
                copyText(JSON.stringify(currentObj, null, 4));
            } else {
                copyText(inputArea.value);
            }
        }



        // Sort/Order Logic (Operates on currentObj)
        function sortJson(asc) {
            if (!currentObj) return;
            currentObj = sortObject(currentObj, asc);
            reRenderTree();
            showToast(asc ? "Â∑≤ÊåâÂú®ÂçáÂ∫èÊéíÂàó" : "Â∑≤ÊåâÈôçÂ∫èÊéíÂàó");
        }

        function reRenderTree() {
            outputDiv.innerHTML = '';
            const tree = buildTree(currentObj, 0, null, true, []);
            outputDiv.appendChild(tree);
        }

        function sortObject(obj, asc) {
            if (Array.isArray(obj)) return obj.map(item => sortObject(item, asc));
            else if (obj !== null && typeof obj === 'object') {
                const keys = Object.keys(obj).sort();
                if (!asc) keys.reverse();
                const newObj = {};
                keys.forEach(key => newObj[key] = sortObject(obj[key], asc));
                return newObj;
            }
            return obj;
        }

        // --- Tree Builder (Nested Block Layout) ---
        function buildTree(data, level, key, isLast, path) {
            const container = document.createElement('div');
            container.className = 'json-node expanded';

            const isObj = typeof data === 'object' && data !== null;
            if (isObj) {
                container.classList.add('object-node');
            }

            // Header Row
            const row = document.createElement('div');
            row.className = 'json-row';

            const lineNum = document.createElement('span');
            lineNum.className = 'line-num';
            row.appendChild(lineNum);

            // Content Box for Key/Value/Preview
            const contentBox = document.createElement('div');
            contentBox.className = 'content-box';

            // No manual padding-left needed anymore, handled by CSS nesting
            // contentBox.style.paddingLeft = ... 

            // Collapser
            if (isObj && Object.keys(data).length > 0) {
                const toggle = document.createElement('span');
                toggle.className = 'collapsible-icon';
                toggle.onclick = (e) => { e.stopPropagation(); toggleNode(container); };
                contentBox.appendChild(toggle);
            } else {
                // Align non-collapsible items if needed, or just let them flow
                if (isObj) {
                    // Empty object
                    const spacer = document.createElement('span');
                    spacer.style.width = '14px';
                    spacer.style.display = 'inline-block';
                    contentBox.appendChild(spacer);
                }
            }

            // Key
            if (key !== null) {
                const keySpan = document.createElement('span');
                keySpan.className = 'key';
                keySpan.textContent = `"${key}"`;
                // Single click to edit key
                keySpan.onclick = (e) => { e.stopPropagation(); handleEditKey(keySpan, path, key); };

                contentBox.appendChild(keySpan);

                const colon = document.createElement('span');
                colon.className = 'punctuation';
                colon.textContent = ': ';
                contentBox.appendChild(colon);
            }

            // Value or Opening Bracket
            if (isObj) {
                const isArr = Array.isArray(data);
                const keys = Object.keys(data);
                const count = keys.length;
                const typeLabel = isArr ? 'Array' : 'Object';

                const open = document.createElement('span');
                open.className = 'punctuation';
                open.textContent = isArr ? '[' : '{';
                open.style.cursor = 'pointer';
                open.ondblclick = (e) => { e.stopPropagation(); toggleNode(container); };
                contentBox.appendChild(open);

                if (count > 0) {
                    // Preview (when collapsed or even expanded for info)
                    // For block layout, maybe only show count when collapsed? 
                    // Or standard "Array(5)" style. Let's keep existing logic.
                    const preview = document.createElement('span');
                    preview.className = 'preview-text';
                    preview.textContent = `${typeLabel}(${count})`;
                    preview.title = "ÁÇπÂáªÂ±ïÂºÄ";
                    preview.onclick = (e) => { e.stopPropagation(); toggleNode(container); };
                    contentBox.appendChild(preview);

                    // If collapsed, show closing bracket here
                    const closeCollapsed = document.createElement('span');
                    closeCollapsed.className = 'punctuation preview-text';
                    closeCollapsed.style.marginLeft = '0';
                    closeCollapsed.textContent = isArr ? ']' : '}';
                    closeCollapsed.onclick = (e) => { e.stopPropagation(); toggleNode(container); };
                    contentBox.appendChild(closeCollapsed);
                } else {
                    const closeEmpty = document.createElement('span');
                    closeEmpty.className = 'punctuation';
                    closeEmpty.textContent = isArr ? ']' : '}';
                    contentBox.appendChild(closeEmpty);
                }
            } else {
                contentBox.appendChild(createValueSpan(data, path));
            }

            // Comma (if not last)
            // Note: For block layout, usually the comma is after the closing bracket of the block.
            // But if we put the comma in the Header row for values, that works.
            // For Objects, we need to handle comma after the footer. 
            // Let's attach comma to the container or footer?
            // Existing logic puts comma in contentBox. For primitives this is fine.
            // For objects, verify where it goes.

            if (!isObj && !isLast) {
                const comma = document.createElement('span');
                comma.className = 'punctuation';
                comma.textContent = ',';
                contentBox.appendChild(comma);
            }

            // Actions (Copy Val etc)
            const actions = document.createElement('div');
            actions.className = 'action-group';

            if (key !== null) {
                const btnKey = document.createElement('button');
                btnKey.className = 'tiny-btn';
                btnKey.textContent = 'Â§çÂà∂ÈîÆ';
                btnKey.onclick = (e) => {
                    e.stopPropagation();
                    copyText(key);
                };
                actions.appendChild(btnKey);
            }

            const btnVal = document.createElement('button');
            btnVal.className = 'tiny-btn';
            btnVal.textContent = 'Â§çÂà∂ÂÄº';
            btnVal.onclick = (e) => {
                e.stopPropagation();
                copyText(typeof data === 'string' ? data : JSON.stringify(data, null, 2));
            };
            actions.appendChild(btnVal);

            if (key !== null) {
                const btnPair = document.createElement('button');
                btnPair.className = 'tiny-btn';
                btnPair.textContent = 'Â§çÂà∂ÈîÆÂÄºÂØπ';
                btnPair.onclick = (e) => {
                    e.stopPropagation();
                    const valStr = JSON.stringify(data, null, 2);
                    const pairStr = `"${key}": ${valStr}`;
                    copyText(pairStr);
                };
                actions.appendChild(btnPair);
            }

            // Add Property Button (Only for Objects/Arrays)
            if (isObj) {
                const btnAdd = document.createElement('button');
                btnAdd.className = 'tiny-btn';
                btnAdd.textContent = 'Êñ∞Â¢ûÂ±ûÊÄß';
                btnAdd.onclick = (e) => { e.stopPropagation(); handleAddProperty(path, Array.isArray(data)); };
                actions.appendChild(btnAdd);

                const btnEdit = document.createElement('button');
                btnEdit.className = 'tiny-btn';
                btnEdit.textContent = 'ÁºñËæë';
                btnEdit.onclick = (e) => { e.stopPropagation(); handleEditSubtree(container, path, data); };
                actions.appendChild(btnEdit);
            }

            contentBox.appendChild(actions);
            row.appendChild(contentBox);
            container.appendChild(row);

            // Children (if object & not empty)
            if (isObj && Object.keys(data).length > 0) {
                const childrenDiv = document.createElement('div');
                childrenDiv.className = 'json-children';

                const keys = Object.keys(data);
                keys.forEach((k, i) => {
                    const nextKey = Array.isArray(data) ? null : k;
                    const childNode = buildTree(data[k], level + 1, nextKey, i === keys.length - 1, [...path, k]);
                    childrenDiv.appendChild(childNode);
                });

                container.appendChild(childrenDiv);

                // Footer Row (Closing Bracket)
                const closeRow = document.createElement('div');
                closeRow.className = 'json-row close-bracket-row';

                const closeLineNum = document.createElement('span');
                closeLineNum.className = 'line-num';
                closeRow.appendChild(closeLineNum);

                const closeContent = document.createElement('div');
                closeContent.className = 'content-box';
                // No manual indent

                const closeSym = document.createElement('span');
                closeSym.className = 'punctuation';
                closeSym.textContent = Array.isArray(data) ? ']' : '}';
                closeContent.appendChild(closeSym);

                if (!isLast) {
                    const comma = document.createElement('span');
                    comma.className = 'punctuation';
                    comma.textContent = ',';
                    closeContent.appendChild(comma);
                }

                closeRow.appendChild(closeContent);
                container.appendChild(closeRow);
            }

            return container;
        }

        function createValueSpan(val, path) {
            const span = document.createElement('span');
            if (typeof val === 'string') {
                span.className = 'string';
                span.textContent = `"${val}"`;
            } else if (typeof val === 'number') {
                span.className = 'number';
                span.textContent = val;
            } else if (typeof val === 'boolean') {
                span.className = 'boolean';
                span.textContent = val;
            } else if (val === null) {
                span.className = 'null';
                span.textContent = 'null';
            }

            // Edit Value on click
            span.onclick = (e) => { e.stopPropagation(); handleEditValue(span, path, val); };

            return span;
        }

        function toggleNode(node) {
            node.classList.toggle('expanded');
            node.classList.toggle('collapsed');
        }

        function toggleAll(expand) {
            const nodes = document.querySelectorAll('.json-node');
            nodes.forEach(node => {
                if (node.querySelector('.collapsible-icon')) {
                    if (expand) {
                        node.classList.remove('collapsed');
                        node.classList.add('expanded');
                    } else {
                        node.classList.remove('expanded');
                        node.classList.add('collapsed');
                    }
                }
            });
        }

        async function copyText(text) {
            try {
                await navigator.clipboard.writeText(text);
                showToast("Â§çÂà∂ÊàêÂäü ‚úÖ");
            } catch (err) {
                const ta = document.createElement("textarea");
                ta.value = text;
                document.body.appendChild(ta);
                ta.select();
                document.execCommand("Copy");
                ta.remove();
                showToast("Â§çÂà∂ÊàêÂäü (ÂÖºÂÆπ) ‚úÖ");
            }
        }

        function showToast(msg) {
            const t = document.getElementById("toast");
            t.textContent = msg;
            t.className = "show";
            setTimeout(() => t.className = t.className.replace("show", ""), 2000);
        }

        // --- Editing Logic ---

        function handleEditKey(element, path, oldKey) {
            const input = document.createElement('input');
            input.type = 'text';
            input.value = oldKey;
            input.className = 'edit-input';

            function commit() {
                const newKey = input.value.trim();
                if (newKey && newKey !== oldKey) {
                    // Path points to the value, so the parent object is path[:-1]
                    const parentPath = path.slice(0, -1);
                    renameKey(parentPath, oldKey, newKey);
                } else {
                    reRenderTree(); // Cancel/Restore
                }
            }

            input.onblur = commit;
            input.onkeydown = (e) => {
                if (e.key === 'Enter') { input.blur(); }
                if (e.key === 'Escape') { reRenderTree(); }
            };

            element.replaceWith(input);
            input.focus();
        }

        function handleEditValue(element, path, oldVal) {
            const input = document.createElement('input');
            input.type = 'text';
            // Show string without quotes for editing convenience, unless it's complex
            input.value = (typeof oldVal === 'string') ? oldVal : JSON.stringify(oldVal);
            input.className = 'edit-input';

            function commit() {
                const raw = input.value; // Don't trim automatically in case of string with spaces
                let newVal;
                try {
                    // Try to parse as JSON (numbers, boolean, null, quoted strings)
                    newVal = JSON.parse(raw);
                } catch (e) {
                    // Fallback to string
                    newVal = raw;
                }

                if (newVal !== oldVal) {
                    setValueByPath(path, newVal);
                } else {
                    reRenderTree();
                }
            }

            input.onblur = commit;
            input.onkeydown = (e) => {
                if (e.key === 'Enter') { input.blur(); }
                if (e.key === 'Escape') { reRenderTree(); }
            };

            element.replaceWith(input);
            input.focus();
        }

        function setValueByPath(path, value) {
            if (path.length === 0) {
                currentObj = value;
            } else {
                let ref = currentObj;
                for (let i = 0; i < path.length - 1; i++) {
                    ref = ref[path[i]];
                }
                ref[path[path.length - 1]] = value;
            }
            saveState();
            reRenderTree();
        }

        function renameKey(parentPath, oldKey, newKey) {
            let parent;
            if (parentPath.length === 0) {
                parent = currentObj;
            } else {
                parent = currentObj;
                for (let i = 0; i < parentPath.length; i++) {
                    parent = parent[parentPath[i]];
                }
            }

            if (Array.isArray(parent)) return; // Should not happen for keys

            // Preserve order
            const keys = Object.keys(parent);
            const newObj = {};
            keys.forEach(k => {
                if (k === oldKey) {
                    newObj[newKey] = parent[oldKey];
                } else {
                    newObj[k] = parent[k];
                }
            });

            // Replace parent content
            if (parentPath.length === 0) {
                currentObj = newObj;
            } else {
                // We need to re-assign the new object to the parent's parent
                // But since we can't easily replace the object reference in the tree without traversing again...
                // Simpler mutation approach: delete all keys and restore new ones
                // This keeps the reference intact
                keys.forEach(k => delete parent[k]);
                Object.assign(parent, newObj);
            }

            saveState();
            reRenderTree();
        }

        function handleAddProperty(path, isArray) {
            let target = currentObj;
            for (let i = 0; i < path.length; i++) {
                target = target[path[i]];
            }

            if (isArray) {
                target.push("Êñ∞ÂÄº");
            } else {
                let i = 1;
                while (target.hasOwnProperty("Êñ∞Â±ûÊÄß" + i)) {
                    i++;
                }
                target["Êñ∞Â±ûÊÄß" + i] = "Êñ∞ÂÄº";
            }

            saveState();
            reRenderTree();
        }

        function handleEditSubtree(container, path, data) {
            // Create editor UI
            const editorDiv = document.createElement('div');
            editorDiv.className = 'subtree-editor-container';

            const textarea = document.createElement('textarea');
            textarea.className = 'subtree-textarea';
            const jsonStr = JSON.stringify(data, null, 4);
            textarea.value = jsonStr;

            // Auto-resize logic
            const lineCount = jsonStr.split('\n').length;
            const lineHeight = 20; // Approx for 13px font * 1.5
            const padding = 20;
            const minHeight = 200;
            const targetHeight = Math.max(minHeight, (lineCount * lineHeight) + padding);
            textarea.style.height = targetHeight + 'px';
            textarea.style.lineHeight = '1.5';

            // Cleanup helper to remove event listener
            const cleanup = () => {
                document.removeEventListener('click', outsideClickListener);
            };

            const outsideClickListener = (e) => {
                // If click is outside the editor container
                if (!editorDiv.contains(e.target)) {
                    cleanup();
                    reRenderTree(); // Cancel/Restore
                }
            };

            // Delay adding the listener to avoid triggering it immediately with the current click
            setTimeout(() => {
                document.addEventListener('click', outsideClickListener);
            }, 0);

            const btnRow = document.createElement('div');
            btnRow.style.display = 'flex';
            btnRow.style.gap = '8px';
            btnRow.style.justifyContent = 'flex-start';

            const btnSave = document.createElement('button');
            btnSave.className = 'btn btn-primary';
            btnSave.textContent = '‰øùÂ≠ò';
            btnSave.style.padding = '4px 12px';
            btnSave.style.fontSize = '12px';

            const btnCancel = document.createElement('button');
            btnCancel.className = 'btn btn-default';
            btnCancel.textContent = 'ÂèñÊ∂à';
            btnCancel.style.padding = '4px 12px';
            btnCancel.style.fontSize = '12px';

            btnSave.onclick = () => {
                cleanup();
                try {
                    const newData = JSON.parse(textarea.value);
                    setValueByPath(path, newData); // This triggers reRenderTree
                } catch (e) {
                    showToast("JSON Ê†ºÂºèÈîôËØØ: " + e.message);
                    // Re-attach listener if we failed to save? 
                    // No, usually we want to keep editing. 
                    // But if we cleanup(), we need to re-attach or just not cleanup if invalid? 
                    // Let's re-attach if we stay open.
                    // Actually simplier: Don't cleanup if error.
                    // But we called cleanup() at start.
                    // Let's fix logic inside: only cleanup on success.
                    document.addEventListener('click', outsideClickListener);
                }
            };

            // Refined Save Logic to handle retry
            btnSave.onclick = (e) => {
                e.stopPropagation(); // Prevent triggering outside click immediately
                try {
                    const newData = JSON.parse(textarea.value);
                    cleanup(); // Only cleanup on success
                    setValueByPath(path, newData);
                } catch (e) {
                    showToast("JSON Ê†ºÂºèÈîôËØØ: " + e.message);
                    textarea.focus();
                }
            };

            btnCancel.onclick = (e) => {
                e.stopPropagation();
                cleanup();
                reRenderTree(); // Restore view
            };

            btnRow.appendChild(btnCancel);
            btnRow.appendChild(btnSave);
            editorDiv.appendChild(textarea);
            editorDiv.appendChild(btnRow);

            // Replace the tree node with the editor
            container.replaceWith(editorDiv);
            textarea.focus();
        }
    </script>
</body>

</html>